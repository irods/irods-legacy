bcGenerateReportsRule {
#  
# Command to be executed - Located in irods/server/bin/cmd/bc_generate_reports
# This invokes a Python code which generates a set of reports based on the XML file 
# generated by the Fiwalk utility, Feature files generated by the Bulk Extractor tool
# and the annotated files generated by the identify_filenames tool.
# Input Parameters are:
#   annotatedFilesDir, 
#   xml file generated by fiwalk tool
#   Configuration file
# Output Parameter is: 
#   Output directory newBcReportsDir where the reports are generated.
# Tool: bc_generate_reports --fiwalk_xmlfile </path/to/xmlfile/> --annotated_dir </path/to/annotatedDir/ \
#                           --outdir </path/to/outdir/> --conf </path/to/configfile/>
#   
# Example: irule -F rulemsiBcGenerateReports.r "*fiwalkXmlFile='/home/sunitha/aaa/x2'" \
#                   "*annotatedDir='/home/sunitha/aaa/ann2'" \
#                   "*outReportsDir='/home/sunitha/aaa/nnn4'" \
#                   "*conf='/home/sunitha/aaa/t'"
#  
    *Cmd="bc_generate_reports";
    #*Arg="--fiwalk_xmlfile " ++ *fiwalkXmlFile ++ " --annotated_dir " ++ *annotatedDir ++ " --outdir " ++ *outReportsDir ++ " --conf " ++ *conf ;
    *timeStamp = double (time());

    # Query the metadata catalog
    # First get the DataID of the xml file. Fail if the file doesn't exist
    msiIsData(*fiwalkXmlFile, *DataID, *Status);
    if (int(*DataID) == 0) {
        writeLine("stdout", "Please enter path to XML file");
        fail;
    }
    
    # hintPath is the 4th argument of msiExecCmd, which is a file on the grid
    # The command will be executed on the host where this file is stored. We can use the file
    # *fiwalkXmlFile for this purpose as we know it is stored on the grid.
    *hintPath = "*fiwalkXmlFile";

    # XML File exists
    
    # Now Make a query to get the path to the config file and the resource name 
    # DATA_PATH: Physical path name for digital object in resource
    # DATA_RESC_NAME: Logical name of storage resource
    *Query = select DATA_PATH, DATA_RESC_NAME where DATA_ID = '*DataID';
    foreach (*row in *Query) {
        *PathToXmlFile = *row.DATA_PATH;
        *Resource = *row.DATA_RESC_NAME;
        writeLine("stdout", "D: Path to XML file = *PathToXmlFile, Resource= *Resource");
 
    }
    
    # Query the metadata catalog for Config File
    # First get the DataID of the config file. Fail if the file doesn't exist
    msiIsData(*conf, *DataID, *Status);
    if (int(*DataID) == 0) {
        writeLine("stdout", "Please enter path to Config file");
        fail;
    }

    # Config File exists
    
    # Now Make a query to get the path to the Config file and the resource name 
    # DATA_PATH: Physical path name for digital object in resource
    # DATA_RESC_NAME: Logical name of storage resource
    *Query_c = select DATA_PATH, DATA_RESC_NAME where DATA_ID = '*DataID';
    foreach (*row in *Query_c) {
        *PathToConfigFile = *row.DATA_PATH;
        *Resource = *row.DATA_RESC_NAME;
        writeLine("stdout", "D: Path to Config file = *PathToConfigFile, Resource= *Resource");
 
    }
    
    # Make another query for IP Address of the resource
    # RESC_LOC: Resource IP Address
    # DATA_RESC_NAME: Logical name of storage resource
    *Query2 = select RESC_LOC where DATA_RESC_NAME = '*Resource';
    foreach (*row in *Query2) {
        *Addr = *row.RESC_LOC;
        writeLine("stdout", "D: Host Name = *Addr, Resource= *Resource");
    }
    
    # Query the metadata catalog for the input directory annotatedDir
    # First get the Colection ID (CollID_beFeat) of the Directory. Fail if the 
    # directory doesn't exist
    msiIsColl(*annotatedDir, *CollID_annotate, *Status_annotate);
    if (int(*CollID_annotate) == 0) {
        writeLine("stdout", "Please enter a Directory name for BE Annotated Files Directory input");
        fail;
    }

    # Get the physical path for the directory/collection for 
    # annotated files directory from DATA_PATH
    *Query3 = select DATA_PATH where COLL_ID = '*CollID_annotate';

    foreach (*row3 in *Query3) {
        *annFile = *row3.DATA_PATH;

        # The collection name is the same for all the files. So get the 
        # collection name for the first one and break out of the loop. 
        msiSplitPath(*annFile, *Coll, *File);

        writeLine("stdout", "D: Feature Directory:annFile: *annFile, PathToAnnDir = *Coll, File=*File");
        *PathToAnnDir = *Coll;
        break;
    }
    
    # store the directory of the base collection for future use
    msiSplitPath(*Coll, *baseCollDir, *annDir); 

    writeLine("stdout", "D: Collection Dir = *PathToAnnDir");
    writeLine("stdout", "D: baseCollDir: *baseCollDir");
    
    # To have a unique name for the generated directory, we will use a prefix
    # with timestamp and user-id. The unique dir will be generated in /tmp
    # directory, which will later be copied to the datagrid.
    *prefixStr = "*timeStamp$userNameClient";
    *tempStr = "/tmp/*prefixStr" ++ "outReportsDir";

    *Arg1 = "--fiwalk_xmlfile";
    *Arg2 = execCmdArg(*PathToXmlFile);      # XmlFile:Input
    *Arg3 = "--annotated_dir";
    *Arg4 = execCmdArg(*PathToAnnDir);       # annotatedDir: Input
    *Arg5 = "--outdir";
    *Arg6 = execCmdArg(*tempStr); # Output Feature Directory
    *Arg7 = "--conf";
    *Arg8 = execCmdArg(*PathToConfigFile);

    writeLine("stdout","iRODS: Generating BitCurator Reports...");
    writeLine ("stdout","Command: *Cmd *Arg1 *Arg2 *Arg3 *Arg4 *Arg5 *Arg6 *Arg7 *Arg8");
    
    if (errorcode(msiExecCmd(*Cmd,"*Arg1 *Arg2 *Arg3 *Arg4 *Arg5 *Arg6 *Arg7 *Arg8","null","*hintPath","null",*Result)) < 0) {
        if(errormsg(*Result,*msg)==0) { 
            msiGetStderrInExecCmdOut(*Result,*Out); 
            writeLine("stdout", "ERROR: *Out");
        } else {
            writeLine("stdout", "Result msg is empty");
        }
    } else {
        # Command executed successfully
        msiGetStdoutInExecCmdOut(*Result,*Out);

        # Display the output from the command
        writeLine("stdout", "Command Output: \n *Out ");
        
        # Copy the files from /tmp to the specified output directory
        # structure recursively.
        writeLine("stdout", "Copying files from *tempStr to *outReportsDir");
        
        copyFiles(*Addr, *tempStr, *outReportsDir, *prefixStr, *CollID_annotate, *hintPath, *status);
        
        # Clean up the temporary files
        cleanup(*Addr, *tempStr, *outReportsDir, *prefixStr, *status); 
    }
    
}
 
# Function: copyFiles()
# copyFiles is called for copying the files in the newly generated directory in
# /tmp to the datagrid.

copyFiles: input string * input string * input string * input string * input integer * input string * output integer -> integer 
copyFiles(*Addr, *tempStr, *outReportsDir, *prefixStr, *CollID_beFeat, *hintPath, *status) {
    
    writeLine("stdout", "copyFiles: Moving *tempStr to *outReportsDir"); 

    remote(*Addr, "null") {
        # Get the list of the generated report files and copy one by one
        # Shell script bcListFiles is used to list the files in the     
        # temporary directory created in /tmp. The files are to be listed in full-path and one per line
        # for the uploadFiles utility function to work,
        # bcListFiles: find $1 -type f -printf "%p\n"
        
        *a1 = execCmdArg(*tempStr);
        msiExecCmd("bcListFiles",*a1, "null", "*hintPath", "null", *Result);
        
        msiGetStdoutInExecCmdOut(*Result, *Out);

        # Call split to put the listed files in an array
        *a = split(*Out, "\n");
        
        ## writeLine("stdout", "D: Files in /tmp:  *Out");
        ## writeLine("stdout", "D: Files in the array are  *a ");
        
        *localRoot = *tempStr;
        
        # Call uploadFiles to copy all the files under *localRoot 
        uploadFiles(*localRoot, *a, *outReportsDir)
    } 
}
    
# Function: cleanup: Calls a script to remove the temporary files created
# in /tmp
cleanup: input string * input string * input string * input string * output integer -> integer 
cleanup(*Addr, *tempStr, *outAnnDir, *prefixStr, *status) {

       writeLine("stdout", "Cleanup: Removing temporary files"); 
       remote(*Addr, "null") {
            *Arg1 =  execCmdArg(*prefixStr);          
            msiExecCmd("tmpCleanup", *Arg1, "null", "null", "null", *Result); 
       }
}    
    
INPUT *fiwalkXmlFile="/AstroZone/home/pixel/bcfiles/bcTestFiwalkXmlfile.xml", *annotatedDir="/AstroZone/home/pixel/bcfiles/bcTestBeAnnDir", *outReportsDir="/AstroZone/home/pixel/bcfiles/outReportsDir", *conf="/AstroZone/home/pixel/bcfiles/bcTestConfigFile"
OUTPUT ruleExecOut
